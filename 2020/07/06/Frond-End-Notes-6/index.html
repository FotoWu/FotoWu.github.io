<!DOCTYPE html><html lang="en-us"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>Frond-End-Notes-6 | Geek Home</title><meta name="description"><meta name="generator" content="Geek Home"><meta name="author" content="Wu Daoyi"><meta name="keywords"><meta name="HandheldFriendly" content="True"><meta name="MobileOptimized" content="320"><meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1,user-scalable=0"><link rel="stylesheet" type="text/css" href="/styles/screen.css"><link rel="apple-touch-icon" sizes="57x57" href="/images/apple-touch-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/images/apple-touch-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/images/apple-touch-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/images/apple-touch-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/images/apple-touch-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/images/apple-touch-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/images/apple-touch-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/images/apple-touch-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-180x180.png"><link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16.png"><link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/images/favicon-96x96.png"><link rel="icon" type="image/png" sizes="128x128" href="/images/favicon-128.png"><link rel="icon" type="image/png" sizes="196x196" href="/images/favicon-196x196.png"><meta name="msapplication-TileColor" content="#FFFFFF"><meta name="msapplication-TileImage" content="mstile-144x144.png"><meta name="msapplication-square70x70logo" content="mstile-70x70.png"><meta name="msapplication-square150x150logo" content="mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="mstile-310x150.png"><meta name="msapplication-square310x310logo" content="mstile-310x310.png"><link rel="stylesheet" href="/css/prism.css" type="text/css"></head><body itemscope itemtype="https://schema.org/WebPage"><header itemscope itemtype="https://schema.org/WPHeader"><div class="logo"></div><h1><a href="/" alt="Geek Home" title="Geek Home" itemprop="headline">Geek Home</a></h1><p itemprop="description"></p><nav itemscope itemtype="https://schema.org/SiteNavigationElement"><ul><li itemprop="name"><a href="/ " alt="home" title="home" itemprop="url">home</a></li><li itemprop="name"><a href="/articles" alt="articles" title="articles" itemprop="url">articles</a></li><li itemprop="name"><a href="/author" alt="author" title="author" itemprop="url">author</a></li></ul></nav><div class="space"></div></header><main itemscope itemtype="https://schema.org/Blog"><article class="full"><h1 itemprop="headline" class="post-heading">Frond-End-Notes-6</h1><span class="post-meta"></span><br><br><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="1-单行溢出和多行溢出"><a href="#1-单行溢出和多行溢出" class="headerlink" title="1. 单行溢出和多行溢出"></a>1. 单行溢出和多行溢出</h3><pre><code>//单行溢出代码
overflow:hidden; 
white-space:nowrap; 
text-overflow:ellipsis;</code></pre><pre><code>//多行溢出代码
display:-webkit-box; overflow:hidden;
text-overflow:ellipsis; word-break:break-all;
-webkit-box-orient:vertical; //子元素应该被水平或垂直排列
-webkit-line-clamp:3; //3行后显示省略号</code></pre><h3 id="2-bfc布局是什么"><a href="#2-bfc布局是什么" class="headerlink" title="2. bfc布局是什么"></a>2. bfc布局是什么</h3><p>块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视CSS渲染的一部分，是块盒子的布局过程发生的区域，也是浮动元素与其他元素交互的区域。</p>
<p>块格式化上下文包含创建它的元素内部的所有内容.</p>
<ul>
<li><p>根元素(<html>)</p>
</li>
<li><p>浮动元素（元素的 float 不是 none）</p>
</li>
<li><p>绝对定位元素（元素的 position 为 absolute 或 fixed）</p>
</li>
<li><p>行内块元素（元素的 display 为 inline-block）</p>
</li>
<li><p>表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）</p>
</li>
<li><p>表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）</p>
</li>
<li><p>匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table）</p>
</li>
<li><p>overflow 值不为 visible 的块元素</p>
</li>
<li><p>display 值为 flow-root 的元素</p>
</li>
<li><p>contain 值为 layout、content或 paint 的元素</p>
</li>
<li><p>弹性元素（display为 flex 或 inline-flex元素的直接子元素）</p>
</li>
<li><p>网格元素（display为 grid 或 inline-grid 元素的直接子元素）</p>
</li>
<li><p>多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）</p>
</li>
<li><p>column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。</p>
</li>
</ul>
<p>块格式化上下文对浮动定位（<strong>float</strong>）与清除浮动（<strong>clear</strong>）都很重要。浮动定位和清除浮动时只会应用于同一个BFC内的元素。浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动。外边距折叠（Margin collapsing）也只会发生在属于同一BFC的块级元素之间。</p>
<h3 id="3-什么是闭包，什么场景会用到闭包？"><a href="#3-什么是闭包，什么场景会用到闭包？" class="headerlink" title="3. 什么是闭包，什么场景会用到闭包？"></a>3. 什么是闭包，什么场景会用到闭包？</h3><p>由于在JS中，变量的作用域属于函数作用域，在函数执行后作用域就会被清理、内存也随之回收，但是由于闭包是建立在一个函数内部的子函数，由于其可访问上级作用域，即使上级函数执行完，作用域也不会随之销毁，这时的子函数——也就是闭包，便拥有了访问上级作用域中的变量的权限，即使上级函数执行完后作用域内的值也不会被销毁。</p>
<p><strong>闭包解决了什么问题？</strong></p>
<p>由于闭包可以缓存上级作用域，那么就使得函数外部打破了“函数作用域”的束缚，可以访问函数内部的变量。以平时使用的Ajax成功回调为例，这里其实就是个闭包，由于上述的特性，回调就拥有了整个上级作用域的访问和操作能力，提高了极大的便利。</p>
<p><strong>什么场景会用到闭包？</strong></p>
<p>闭包随处可见，一个Ajax请求的成功回调，一个事件绑定的回调方法，一个setTimeout的延时回调，或者一个函数内部返回另一个匿名函数，这些都是闭包。简而言之，无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都有闭包的身影。</p>
<h3 id="4-什么是跨域，如何实现跨域"><a href="#4-什么是跨域，如何实现跨域" class="headerlink" title="4. 什么是跨域，如何实现跨域"></a>4. 什么是跨域，如何实现跨域</h3><p>a. 广义跨域：一个域下的文档或脚本试图去请求另一个域下的资源</p>
<pre><code>1.) 资源跳转： A链接、重定向、表单提交
2.) 资源嵌入： &lt;link&gt;、&lt;script&gt;、&lt;img&gt;、
     &lt;frame&gt;等dom标签，
    还有样式中background:url()、
    @font-face()等文件外链
3.) 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等</code></pre><p>b. 狭义跨域：由浏览器同源策略限制的一类请求场景。</p>
<p>同源：”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>
<p>同源策略限制以下三种操作：</p>
<pre><code>1.) Cookie、LocalStorage 和 IndexDB 无法读取
2.) DOM 和 Js对象无法获得
3.) AJAX 请求不能发送</code></pre><p>解决方法：</p>
<pre><code>1、 通过jsonp跨域
2、 document.domain + iframe跨域
3、 location.hash + iframe
4、 window.name + iframe跨域
5、 postMessage跨域
6、 跨域资源共享（CORS）
7、 nginx代理跨域
8、 nodejs中间件代理跨域
9、 WebSocket协议跨域</code></pre><ol>
<li>通过jsonp跨域</li>
</ol>
<p>通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过<strong>动态创建script，再请求一个带参网址</strong>实现跨域通信。缺点是<strong>只能实现get一种请求</strong>。</p>
<p>a. 原生实现</p>
<pre><code>&lt;script&gt;
 var script = document.createElement(&#39;script&#39;);
    script.type = &#39;text/javascript&#39;;   
 // 传参并指定回调执行函数为onBack
 script.src = &#39;http://www.domain2.com:8080/
              login?user=admin&amp;callback=onBack&#39;;    
 document.head.appendChild(script);    
 // 回调执行函数
    function onBack(res) {
        alert(JSON.stringify(res));
    } &lt;/script&gt;</code></pre><p>服务器返回（执行全局函数）</p>
<pre><code>onBack({&quot;status&quot;: true, &quot;user&quot;: &quot;admin&quot;})</code></pre><p>b. jQuery Ajax</p>
<pre><code>$.ajax({    
url: &#39;http://www.domain2.com:8080/login&#39;,    
type: &#39;get&#39;,    dataType: &#39;jsonp&#39;,  
// 请求方式为jsonp
    jsonpCallback: &quot;onBack&quot;,    
// 自定义回调函数名
    data: {}
});</code></pre><p>c. vue.js</p>
<pre><code>this.$http.jsonp(&#39;
http://www.domain2.com:8080/login&#39;, 
{    
params: {},    
jsonp: &#39;onBack&#39;}).then((res) =&gt; 
{    console.log(res); 
})</code></pre><p>后端node.js代码</p>
<pre><code>var querystring = require(&#39;querystring&#39;);
var http = require(&#39;http&#39;);
var server = http.createServer();
server.on(&#39;request&#39;, function(req, res) {    
var params = qs.parse(req.url.split(&#39;?&#39;)[1]);    
var fn = params.callback;    
// jsonp返回设置
    res.writeHead(200, { 
&#39;Content-Type&#39;: &#39;text/javascript&#39; });
    res.write(fn + &#39;(&#39; + 
       JSON.stringify(params) + &#39;)&#39;);
    res.end();
});
server.listen(&#39;8080&#39;);
console.log(&#39;Server is running at port 8080...&#39;);</code></pre><ol start="2">
<li>document.domain + iframe跨域</li>
</ol>
<p><strong>仅限主域相同，子域不同的跨域应用场景。</strong></p>
<p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p>
<ol start="3">
<li>location.hash + iframe跨域</li>
</ol>
<p>实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p>
<p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p>
<ol start="4">
<li>window.name + iframe跨域</li>
</ol>
<p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p>
<p>a.html</p>
<pre><code>var proxy = function(url, callback) 
{    
 var state = 0;    
var iframe = document.createElement(&#39;iframe&#39;);    
 // 加载跨域页面
 iframe.src = url;    
 // onload事件会触发2次，
 第1次加载跨域页，
并留存数据于window.name
iframe.onload = function()
  {        
  if (state === 1) 
  {            
 // 第2次onload(同域proxy页)成功后，
 读取同域window.name中数据
callback(iframe.contentWindow.name);
  destoryFrame();
   } 
else if (state === 0) 
  {            
 // 第1次onload(跨域页)成功后，
 切换到同域代理页面
 iframe.contentWindow.location = 
  &#39;http://www.domain1.com/proxy.html&#39;;
  state = 1;
    }
    };    
 document.body.appendChild(iframe);    
  // 获取数据以后销毁这个iframe，
  释放内存；
 这也保证了安全（不被其他域frame js访问）
 function destoryFrame() {
 iframe.contentWindow.document.write(&#39;&#39;);
 iframe.contentWindow.close();        
  document.body.removeChild(iframe);
    }
};
 // 请求跨域b页面数据proxy
 (&#39;http://www.domain2.com/b.html&#39;, 
 function(data)
     {
    alert(data);
});</code></pre><ol start="5">
<li>postMessage跨域</li>
</ol>
<p>postMessage是HTML5(XMLHttpRequest Level 2)中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p>
<pre><code>a.） 页面和其打开的新窗口的数据传递
b.） 多窗口之间消息传递
c.） 页面与嵌套的iframe消息传递
d.） 上面三个场景的跨域数据传递</code></pre><p>用法：postMessage(data,origin)方法接受两个参数<br>data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用<strong>JSON.stringify()</strong>序列化。<br>origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</p>
<ol start="6">
<li>跨域资源共享（CORS）</li>
</ol>
<p>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带<strong>cookie请求</strong>：前后端都需要设置。</p>
<p><strong>前端设置</strong></p>
<p>a. 原生ajax</p>
<pre><code>// 前端设置是否带
cookiexhr.withCredentials = true;</code></pre><p>b. jquery ajax</p>
<pre><code>$.ajax({
    ...
 xhrFields: {
 withCredentials: true    
 // 前端设置是否带cookie   
 },
 crossDomain: true,   
 // 会让请求头中包含跨域的额外信息，
 但不会含cookie
    ...
});</code></pre><p>c. vue.js</p>
<p>在vue-resource封装的ajax组件中加入以下代码：</p>
<pre><code>Vue.http.options.credentials = true</code></pre><p><strong>后端设置</strong></p>
<p>a. Java</p>
<pre><code>/*
 * 导入包：
  import javax.servlet.http.HttpServletResponse;
 * 接口参数中定义：
  HttpServletResponse response
 */response.setHeader
  (&quot;Access-Control-Allow-Origin&quot;,
 &quot;http://www.domain1.com&quot;);  
// 若有端口需写全（协议+域名+端口）
response.setHeader
(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;);</code></pre><p>b. node.js</p>
<pre><code>var http = require(&#39;http&#39;);
var server = http.createServer();
var qs = require(&#39;querystring&#39;);
server.on(&#39;request&#39;, function(req, res) 
{    
var postData = &#39;&#39;;    
// 数据块接收中
 req.addListener(&#39;data&#39;, 
  function(chunk) {
   postData += chunk;
    });    
// 数据接收完毕
 req.addListener(&#39;end&#39;, 
function() 
{
  postData = qs.parse(postData);        
// 跨域后台设置
   res.writeHead(200, {           
&#39;Access-Control-Allow-Credentials&#39;: 
  &#39;true&#39;,    
 // 后端允许发送Cookie
 &#39;Access-Control-Allow-Origin&#39;: 
 &#39;http://www.domain1.com&#39;,   
 // 允许访问的域（协议+域名+端口）
   &#39;Set-Cookie&#39;: 
 &#39;l=a123456;Path=/;Domain=www.domain2.com;
  HttpOnly&#39;  
  // HttpOnly:脚本无法读取cookie
        });
  res.write(JSON.stringify(postData));
   res.end();
    });
});
server.listen(&#39;8080&#39;);
console.log(&#39;Server is running at port 8080...&#39;);</code></pre><ol start="7">
<li>nginx代理跨域</li>
</ol>
<p>跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨域问题。</p>
<p>实现思路：通过nginx配置一个代理服务器（<strong>域名与domain1相同，端口不同</strong>）做跳板机，反向代理访问domain2接口，并且可以<strong>顺便修改cookie中domain信息</strong>，方便当前域cookie写入，实现跨域登录。</p>
<ol start="8">
<li>Nodejs中间件代理跨域</li>
</ol>
<p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p>
<p>a. 非vue框架的跨域（两次）<br>利用node + express + http-proxy-middleware搭建一个proxy服务器。</p>
<p>b. vue 框架跨域（一次）</p>
<p>利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。</p>
<ol start="9">
<li>WebSocket协议跨域</li>
</ol>
<p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时<strong>允许跨域通讯</strong>，是server push技术的一种很好的实现。</p>
<p>我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p>
<h3 id="5-重绘与回流"><a href="#5-重绘与回流" class="headerlink" title="5. 重绘与回流"></a>5. 重绘与回流</h3><p>回流：当<strong>Render Tree</strong>中部分或全部元素的尺寸、结构、或某些属性发生改变时，浏览器重新渲染部分或全部文档的过程称为回流。</p>
<p>会导致回流的操作：</p>
<pre><code>页面首次渲染
浏览器窗口大小发生改变
元素尺寸或位置发生改变
元素内容变化（文字数量或图片大小等等）
元素字体大小变化
添加或者删除可见的DOM元素
激活CSS伪类（例如：:hover）
查询某些属性或调用某些方法</code></pre><p>重绘：当页面中元素样式的改变并不影响它在文档流中的位置时（例如：<strong>color、background-color、visibility</strong>等），浏览器会将新样式赋予给元素并重新绘制它，这个过程称为重绘。</p>
<p>性能影响：回流的代价比重绘高，有时即使仅仅回流一个单一的元素，它的父元素以及任何跟随它的元素也会产生回流。</p>
<p>现代浏览器会对频繁的回流或重绘操作进行优化：浏览器会维护一个队列，把所有引起回流和重绘的操作放入队列中，如果队列中的任务数量或者时间间隔达到一个阈值的，浏览器就会将队列清空，进行一次批处理，这样可以把多次回流和重绘变成一次。</p>
<p>如何避免？</p>
<p>CSS：</p>
<pre><code>避免使用table布局。
尽可能在DOM树的最末端改变class。
避免设置多层内联样式。
将动画效果应用到position属性为absolute或fixed的元素上。
避免使用CSS表达式（例如：calc()）。</code></pre><p>JavaScript:</p>
<pre><code>避免频繁操作样式，最好一次性重写style属性，或者将样式列表定义为class并一次性更改class属性。
避免频繁操作DOM，创建一个documentFragment，在它上面应用所有DOM操作，最后再把它添加到文档中。
也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。</code></pre><h3 id="6-ES6新特性"><a href="#6-ES6新特性" class="headerlink" title="6. ES6新特性"></a>6. ES6新特性</h3><p>a. 异步编程 Promise,async/await<br>b. class,module<br>c. set, map等数据结构<br>d. let块级作用域<br>e. 原生对象的方法扩展：如String的遍历、repeat()，Number的parseInt()，function的箭头函数，Array的扩展运算符(…)等</p>
<p>ES6中5种遍历对象属性的方法</p>
<pre><code>for-in——自身和继承的可枚举属性（除Symbol）
Object.keys()——自身非继承的可枚举属性（除Symbol）
Object.getOwnPropertyNames()——自身所有属性键名（包括不可枚举、除Symbol）
Object.getOwnPropertySymbols()——自身的所有 
Symbol 属性的键名Reflect.ownKeys()——自身的所有键名</code></pre><h3 id="7-HTTP缓存（精）"><a href="#7-HTTP缓存（精）" class="headerlink" title="7. HTTP缓存（精）"></a>7. HTTP缓存（精）</h3><p>Header：</p>
<pre><code>Expires: 响应头，代表该资源的过期时间
Cache-Control: 请求/响应头，缓存控制，精确控制缓存策略
If-Modified-Since: 请求头，资源最近修改时间，浏览器-&gt;服务器
Last-Modified: 响应头，资源最近修改时间，服务器-&gt;浏览器
Etag: 响应头，资源唯一标识，服务器-&gt;浏览器
If-None-Match: 请求头，缓存资源标识，浏览器-&gt;服务器</code></pre><p>配对使用的字段：<br>If-Modified-Since和Last-Modified<br>If-None-Match和Etag</p>
<p>Cache-Control控制粒度更细，包括max-age, no-cache, public, private, no-store等等</p>
</article><br><br><span class="next-post"><a href="/2020/06/03/LeetCode767/" itemprop="url">Older Post ⇒</a></span><span class="prev-post"><a href="/2020/07/07/InterviewBytedance/" itemprop="url">⇐ Next Post </a></span><br><br><br></main></body></html>